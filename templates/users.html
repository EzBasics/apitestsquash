<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>User Profiles</title>
  <!-- Load Chart.js from a CDN -->
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='ccsquash.jpg') }}" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --hero-bg: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      --widget-bg: #fff;
    }
    html {
      font-size: 18px;
      scroll-behavior: smooth;
    }
    .widget-container {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin: 20px auto;
      max-width: 1200px;
    }
    body {
      background: url("{{ url_for('static', filename='ussquashbackgroundfull.png') }}");
      background-repeat: repeat;
      background-position: center;
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      color: #333;
      line-height: 1.5;
    }
/* Navbar Container */
.navbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.95); /* Semi-transparent white */
  backdrop-filter: blur(10px); /* Frosted glass effect */
  z-index: 1000;
  padding: 10px 0;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.nav-wrapper {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 20px; /* Space between left and right sections */
}

/* Nav Sections (Left and Right) */
.nav-section {
  display: flex;
  align-items: center;
  gap: 20px; /* Space between items in each section */
}

/* Logo */
.logo img {
  width: 50px;
  height: 50px;
  transition: transform 0.3s ease;
}

.logo img:hover {
  transform: scale(1.1);
}

/* Navigation Links */
.nav-links {
  display: flex;
  align-items: center;
  list-style: none;
  margin: 0;
  padding: 0;
  gap: 15px; /* Space between links */
}

.nav-links li a {
  color: #333;
  font-size: 1rem;
  font-weight: 500;
  text-decoration: none;
  padding: 8px 12px;
  border-radius: 8px;
  transition: all 0.3s ease;
  position: relative;
}

.nav-links li a:hover {
  color: #4facfe;
  background: rgba(79, 172, 254, 0.1);
}

.nav-links li a::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 50%;
  width: 0;
  height: 2px;
  background: #4facfe;
  transform: translateX(-50%);
  transition: width 0.3s ease;
}

.nav-links li a:hover::after {
  width: 100%;
}

/* Search Bar */
.search-container {
  position: relative;
}

.nav-search {
  width: 200px;
  height: 40px;
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 25px;
  font-size: 0.9rem;
  background: #f8f8f8;
  transition: all 0.3s ease;
}

.nav-search:focus {
  outline: none;
  border-color: #4facfe;
  box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.2);
  background: #fff;
}

/* Edit Mode Toggle */
.edit-mode-toggle {
  display: flex;
  align-items: center;
  gap: 10px;
}

.edit-mode-toggle label {
  font-size: 0.9rem;
  color: #666;
  font-weight: 500;
}

.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 26px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #e0e0e0;
  border-radius: 34px;
  transition: 0.4s;
}

.slider:before {
  position: absolute;
  content: '';
  height: 20px;
  width: 20px;
  left: 3px;
  bottom: 3px;
  background: white;
  border-radius: 50%;
  transition: 0.4s;
}

input:checked + .slider {
  background: #4facfe;
}

input:checked + .slider:before {
  transform: translateX(24px);
}

/* Responsive Adjustments */
@media (max-width: 768px) {
  .nav-wrapper {
    flex-direction: column;
    gap: 10px;
  }

  .nav-section {
    flex-direction: column;
    gap: 10px;
  }

  .nav-links {
    flex-wrap: wrap;
    justify-content: center;
  }

  .nav-search {
    width: 100%;
  }
}
    .container {
      max-width: 1200px;
      margin: 120px auto 0;
      padding: 40px 15px;
    }
    h1, h2 {
      text-align: center;
      margin: 1rem 0;
    }
    .hero {
      padding: 1.2rem 1rem;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 1.5rem;
      background-size: contain;
    }
    .hero-card {
      background: var(--widget-bg);
      border-radius: 12px;
      width: 500px;
      height: 220px;
      margin: 0 auto;
      position: relative;
      box-shadow: 3px 3px 3px 8px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .profile-image-container {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid #fff;
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: transparent;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }
    .profile-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .profile-name {
      margin-top: 45px;
      font-size: 1.4rem;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .profile-location {
      font-size: 1rem;
      color: #666;
      margin: 0.3rem 0;
    }
    .profile-rating {
      font-size: 1rem;
      color: #333;
      font-weight: 600;
    }
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 1rem 0;
    }
    .edit-mode-toggle label {
      margin-right: 8px;
      font-weight: 600;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
      margin: 0 8px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: '';
      height: 22px; 
      width: 22px;
      left: 4px; 
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #4facfe;
    }
    input:focus + .slider {
      box-shadow: 0 0 1px #4facfe;
    }
    input:checked + .slider:before {
      transform: translateX(30px);
    }
    #addWidgetBtn {
      display: none;
      font-size: 1.2rem;
      padding: 10px 15px;
      cursor: pointer;
      background: #4facfe;
      color: #fff;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }
    #widgetAddTable {
      display: none;
      margin: 1rem auto;
    }
    .table-container {
      max-height: 200px;
      overflow: hidden;
      padding-bottom: 40px;
      position: relative;
    }
    .view-more-btn {
      margin-top: 10px;
      cursor: pointer;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background-color: #4facfe;
      color: #fff;
      font-size: 0.9rem;
    }
    .view-more-btn:disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    .widget-grid {
      display: flex;
      gap: 1rem;
      margin-top: 20px;
      margin-bottom: 2rem;
    }
    .widget-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-height: 300px;
    }
    .drop-zone {
      display: none;
      border: 2px dashed #ccc;
      padding: 15px;
      text-align: center;
      color: #777;
      font-size: 1rem;
      min-height: 60px;
      transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
    }
    .drop-zone.drop-highlight {
      border-color: #007BFF;
      background-color: #e8f0fe;
      transform: scale(1.02);
    }
    .grid-item {
      background: var(--widget-bg);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      text-align: center;
      padding: 8px;
      transition: transform 0.2s;
      position: relative;
      font-size: 0.8rem;
    }
    .grid-item.dragging {
      transform: scale(0.95);
      border: 2px solid green;
    }
    .grid-item.highlight {
      outline: 2px dashed #4facfe;
    }
    .remove-widget-btn {
      display: none;
      position: absolute;
      top: 8px;
      right: 8px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 1.4rem;
      line-height: 28px;
      cursor: pointer;
      z-index: 2;
    }
    .grid-item.edit-mode-active .remove-widget-btn {
      display: block;
    }
    #ratingsWidget {
      font-size: 1.2rem;
    }
    #ratingsWidget h3 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    #currentRatingValue.big-rating {
      font-size: 2.3rem;
      font-weight: 700;
      margin: 0.3rem 0;
    }
    #highestRatingValue {
      font-size: 1.2rem;
      font-weight: 600;
      color: #666;
      margin: 0.3rem 0;
    }
    .chart-header {
      width: 100%;
      text-align: center;
      margin-bottom: 5px;
    }
    .chart-title-total {
      font-size: 1.1rem;
      font-weight: bold;
      margin-bottom: 3px;
    }
    .legend {
      font-size: 0.85rem;
    }
    .donut-chart-wrapper {
      width: 180px;
      height: 180px;
      margin: 0 auto;
    }
    .affiliation-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .affiliation-logo {
      width: 40px;
      height: 40px;
      object-fit: contain;
      margin-right: 8px;
      border-radius: 4px;
    }
    .affiliation-text {
      font-size: 1rem;
      color: #333;
    }
    .affiliations-container {
      max-height: 200px;
      overflow: hidden;
      padding-bottom: 30px;
    }
    #searchResults {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      width: 250px;
      display: none;
      z-index: 1001;
      max-height: 250px;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      border-radius: 4px;
      font-size: 1.2rem;
    }
    #searchResults div {
      display: flex;
      align-items: center;
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      transition: background-color 0.3s;
    }
    #searchResults div:hover {
      background-color: #f0f0f0;
    }
    #searchResults img {
      width: 24px;
      height: 24px;
      margin-right: 8px;
      border-radius: 50%;
    }
    .rating-change-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin: 4px 0;
      border-radius: 8px;
      background: #f4f8fc;
      transition: background 0.3s ease;
      font-size: 0.9rem;
    }
    .rating-change-item:hover {
      background: #e0f7ff;
    }
    .rating-change-item .month {
      font-weight: 600;
    }
    .rating-change-item .diff {
      font-size: 1rem;
      font-weight: 600;
    }
    .yearly-change {
      display: inline-block;
      font-size: 1.1rem;
      font-weight: 700;
      color: #2f80ed;
      background: #f4f8fc;
      padding: 6px 10px;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    table.styled-table {
      width: 100%;
      border-collapse: collapse;
      margin: 0 auto;
      font-size: 0.95rem;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      background-color: white;
    }
    table.styled-table thead tr {
      background-color: #4facfe;
      color: #fff;
      text-align: left;
      font-weight: bold;
    }
    table.styled-table thead tr th:first-child {
      text-align: center;
    }
    table.styled-table th, table.styled-table td {
      padding: 12px 16px;
    }
    table.styled-table tbody tr {
      border-bottom: 1px solid #ddd;
    }
    table.styled-table tbody tr:nth-of-type(even) {
      background-color: #f8f8f8;
    }
    table.styled-table tbody tr:hover {
      background-color: #e0f7ff;
    }
    table.styled-table tbody tr td:first-child {
      text-align: center;
    }
    .event-card.win {
      background: #e8f5e9; /* Light green background for wins */
      border-left: 4px solid #4CAF50; /* Green accent border */
    } 

    .event-card.lose {
      background: #ffebee; /* Light red background for losses */
      border-left: 4px solid #f44336; /* Red accent border */
    }
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 500px;
      border-radius: 10px;
      position: relative;
    }
    .close {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close:hover,
    .close:focus {
      color: #000;
      text-decoration: none;
    }
    /* Completed Matches Widget Styles */
    .match-box {
      background-color: #fff;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .match-cards {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .event-card {
      background-color: #fff;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      gap: 15px;
      cursor: pointer;
    }
    .event-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 15px rgba(0,0,0,0.15);
    }
    .event-logo {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
    }
    .event-details {
      flex: 1;
      text-align: left;
    }
    .event-details p {
      margin: 5px 0;
    }
    .insights-btn {
      background-color: #007BFF;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
    }
    .insights-btn:hover {
      background-color: #0056b3;
    }
    
    
    .results-box::-webkit-scrollbar {
      display: none;
    }
    .results-box {
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .event-card {
      background-color: #fff;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 15px;
      cursor: pointer;
    }
    .event-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 15px rgba(0,0,0,0.15);
    }
    .event-logo {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 50%;
    }
    .event-details {
      flex: 1;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .event-details p {
      font-size: 1rem;
      color: #333;
    }
    .event-details p strong {
      color: #007BFF;
    }
    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0; 
      top: 0;
      width: 100%; 
      height: 100%;
      background-color: rgba(0,0,0,0.7);
    }
    .modal .modal-content {
      background: #fff;
      margin: 1% auto;
      padding: 20px;
      width: 90%;
      max-width: 1200px;
      border-radius: 25px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
      position: relative;
      animation: fadeIn 0.5s;
      text-align: center;
      max-height: 80vh;
      overflow-y: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .modal .modal-content::-webkit-scrollbar {
      display: none;
    }
    @keyframes fadeIn {
      from { 
        opacity: 0; 
        transform: translateY(-10px); 
      }
      to { 
        opacity: 1; 
        transform: translateY(0); 
      }
    }
    .close-btn {
      position: absolute;
      right: 30px;
      top: 20px;
      color: #888;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close-btn:hover {
      color: #000;
    }
    .scorecard-item {
      font-size: 18px;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
      text-align: center;
      position: relative;
    }
    .scorecard-item p {
      margin: 5px 0;
    }
    /* Tab styles - "section-like" buttons */
    #tab-nav {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    .tab-button {
      display: inline-block;
      padding: 15px 25px;
      cursor: pointer;
      border: none;
      background-color: #eaeaea;
      color: #333;
      border-radius: 8px;
      transition: background-color 0.3s ease;
      font-size: 1.1rem;
      font-weight: bold;
    }
    .tab-button:hover {
      background-color: #ccc;
    }
    .tab-button.active {
      background-color: #007BFF;
      color: #fff;
    }
    .tab-content-pane {
      display: none;
      margin-bottom: 20px;
    }
    /* Add to existing styles */
    .timeframe-btns-container {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 15px 0;
    }

    .timeframe-btn {
      padding: 8px 16px;
      border: 2px solid #4facfe;
      border-radius: 20px;
      background: white;
      color: #4facfe;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .timeframe-btn:hover {
      background: #e8f3ff;
      transform: translateY(-1px);
    }

    .timeframe-btn.active {
      background: #4facfe;
      color: white;
      border-color: #4facfe;
      box-shadow: 0 2px 6px rgba(79, 172, 254, 0.3);
    }

  </style>
</head>
<body>
  
  <!-- Navigation -->
  <div class="navbar">
    <div class="nav-wrapper">
      <!-- Left Section: Logo and Main Links -->
      <div class="nav-section left">
        <div class="logo">
          <a href="/">
            <img src="{{ url_for('static', filename='logo.png') }}" alt="Logo">
          </a>
        </div>
        <ul class="nav-links">
          <li><a href="/">Roster</a></li>
          <li><a href="standings">Standings</a></li>
          <li><a href="compare">Compare</a></li>
          <li><a href="users">Players</a></li>
        </ul>
      </div>
  
      <!-- Right Section: Search, Links, and Toggle -->
      <div class="nav-section right">
        <div class="search-container">
          <input id="navSearch" type="search" placeholder="Player Search..." class="nav-search">
          
        </div>
        <ul class="nav-links">
          <li><a href="live">Live</a></li>
          <li><a href="schedule">Schedule</a></li>
          <li><a href="allteamsschedule">Matches</a></li>
        </ul>
        <div class="edit-mode-toggle">
          <label for="editModeToggle">Edit Mode</label>
          <label class="switch">
            <input type="checkbox" id="editModeToggle">
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- Search Results Dropdown -->
  <div id="searchResults"></div>

  <div class="container">
    <!-- Hero Section -->
    <section class="hero">
      <div class="hero-card">
        <div class="profile-image-container">
          <img src="https://ussq-img-live.s3.us-east-1.amazonaws.com/uploads%2Fussq-profile-icon-default.png" alt="Profile Picture" class="profile-img">
        </div>
        <h2 class="profile-name" id="heroName">Name Here</h2>
        <p class="profile-location" id="heroLocation">Location Here</p>
        <p class="profile-rating" id="heroRating">Rating: --</p>
      </div>
    </section>
    
    <!-- Controls: Only show Add Widget button in edit mode -->
    <div class="controls">
      <button id="addWidgetBtn">Add Widget</button>
    </div>
    
    <!-- Table for Re-Adding Removed Widgets -->
    <table class="styled-table" id="widgetAddTable" style="display:none;">
      <thead>
        <tr>
          <th>Removed Widget</th>
          <th style="text-align: center;">Restore</th>
        </tr>
      </thead>
      <tbody id="widgetAddTableBody"></tbody>
    </table>
    
    <div class="widget-container">
      <div id="widgetGrid" class="widget-grid">
        <!-- Left Column -->
        <div id="leftColumn" class="widget-column">
          <!-- Ratings Widget -->
          <div class="grid-item" id="ratingsWidget">
            <button class="remove-widget-btn">×</button>
            <h3>Ratings</h3>
            <div>
              <div id="currentRatingValue" class="big-rating">--</div>
              <div>Universal Squash Rating</div>
            </div>
            <div>
              <div id="highestRatingValue">--</div>
              <div>Highest <span id="highestRatingDateValue">--</span></div>
            </div>
          </div>

          <!-- Completed Matches Widget -->
          <div class="grid-item match-box results-box" id="completedMatchesWidget">
            <button class="remove-widget-btn">×</button>
            <h2>Completed Matches</h2>
            <div class="match-cards results-cards" id="completedMatchesContent">
              <!-- Completed match events injected here -->
            </div>
          </div>
          
          <!-- Doubles Wins Widget -->
          <div class="grid-item" id="doublesWinsBox">
            <button class="remove-widget-btn">×</button>
            <div id="doublesWinsChart-header" class="chart-header">
              <div class="chart-title-total"></div>
              <div id="doublesWinsChart-legend" class="legend"></div>
            </div>
            <div class="donut-chart-wrapper">
              <canvas id="doublesWinsChart" class="donut-chart"></canvas>
            </div>
          </div>
          <!-- Leagues Widget -->
          <div class="grid-item" id="leaguesWidget">
            <button class="remove-widget-btn">×</button>
            <h3>Leagues</h3>
            <div id="leaguesList"></div>
          </div>
          <!-- Schools Widget -->
          <div class="grid-item" id="schoolsWidget">
            <button class="remove-widget-btn">×</button>
            <h3>Schools</h3>
            <div id="schoolsContent"></div>
          </div>
 

          <!-- Left Column Drop Zone (edit mode only) -->
          <div class="drop-zone" data-column="left">Drop widget here</div>
        </div>
        
        <!-- Right Column -->
        <div id="rightColumn" class="widget-column">

            <!-- Long Term Rating History Widget -->
            <div class="grid-item" id="ratingsTimeFrameCard">
              <button class="remove-widget-btn">×</button>
              <h3>Rating History</h3>
              <!-- Time frame select populated dynamically -->
              <div id="timeFrameButtons" class="timeframe-btns-container"></div>
              <canvas id="ratingsTimeFrameChart"></canvas>
            </div>
          <!-- Singles Wins Widget -->
          <div class="grid-item" id="Single Wins">
            <button class="remove-widget-btn">×</button>
            <div id="singlesWinsChart-header" class="chart-header">
              <div class="chart-title-total"></div>
              <div id="singlesWinsChart-legend" class="legend"></div>
            </div>
            <div class="donut-chart-wrapper">
              <canvas id="singlesWinsChart" class="donut-chart"></canvas>
            </div>
          </div>
          <!-- Singles Losses Widget -->
          <div class="grid-item" id="Singles Losses">
            <button class="remove-widget-btn">×</button>
            <div id="singlesLossesChart-header" class="chart-header">
              <div class="chart-title-total"></div>
              <div id="singlesLossesChart-legend" class="legend"></div>
            </div>
            <div class="donut-chart-wrapper">
              <canvas id="singlesLossesChart" class="donut-chart"></canvas>
            </div>
          </div>
          <!-- Doubles Losses Widget -->
          <div class="grid-item" id="doublesLossesBox">
            <button class="remove-widget-btn">×</button>
            <div id="doublesLossesChart-header" class="chart-header">
              <div class="chart-title-total"></div>
              <div id="doublesLossesChart-legend" class="legend"></div>
            </div>
            <div class="donut-chart-wrapper">
              <canvas id="doublesLossesChart" class="donut-chart"></canvas>
            </div>
          </div>
          <!-- Affiliations Widget -->
          <div class="grid-item" id="affiliationsWidget">
            <button class="remove-widget-btn">×</button>
            <h3>Affiliations</h3>
            <div id="affiliationsListContainer" class="affiliations-container"></div>
          </div>
          <!-- Monthly Rating Change Widget -->
          <div class="grid-item" id="ratingChangeWidget">
            <button class="remove-widget-btn">×</button>
            <h3>Monthly Rating Change</h3>
            <div id="yearlyRatingChange" class="yearly-change"></div>
            <div id="ratingChangeList"></div>
          </div>

          <!-- Right Column Drop Zone (edit mode only) -->
          <div class="drop-zone" data-column="right">Drop widget here</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Modal for Match Insights -->
  <div id="matchModal" class="modal">
    <div class="modal-content">
      <span class="close" id="modalClose">&times;</span>
      <div id="modalBody">Loading...</div>
    </div>
  </div>
  
  <!-- NEW: Modal for Graph Insights -->
  <div id="graph-modal" class="modal">
    <div class="modal-content">
      <span class="close" id="graph-close">&times;</span>
      <div id="graph-status"></div>
      <div id="metrics-container"></div>
    </div>
  </div>
  
  <script>
    /* === Helper to format ratings === */
    function formatRating(num) {
      let n = parseFloat(num).toFixed(2);
      return n.endsWith("0") ? parseFloat(num).toFixed(1) : n;
    }
    
    /* === Helper to format durations in seconds === */
    function formatDurationSec(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}m ${secs}s`;
    }
    
    /* === Update URL with user_id for state persistence === */
    function updateURLWithUser(userId) {
      history.pushState(null, '', '?user_id=' + userId);
    }
    
    /* === Global Variables === */
    let removedWidgets = [];
    let editMode = false;
    let draggingItem = null;
    let candidateWidget = null;
    let candidateDropZone = null;
    let currentUserId = 328331;
    
    // Chart instances stored globally to avoid canvas reuse issues
    let singlesWinsChart, singlesLossesChart, doublesWinsChart, doublesLossesChart;
    
    const editModeToggle = document.getElementById('editModeToggle');
    const addWidgetBtn = document.getElementById('addWidgetBtn');
    const widgetAddTable = document.getElementById('widgetAddTable');
    const widgetAddTableBody = document.getElementById('widgetAddTableBody');
    const searchInput = document.getElementById('navSearch');
    const searchResultsDiv = document.getElementById('searchResults');
    
    /* === Toggle Edit Mode === */
    editModeToggle.addEventListener('change', (e) => {
      editMode = e.target.checked;
      addWidgetBtn.style.display = editMode ? 'inline-block' : 'none';
      document.querySelectorAll('.drop-zone').forEach(zone => {
        zone.style.display = editMode ? 'block' : 'none';
      });
      document.querySelectorAll('.view-more-btn').forEach(btn => { 
        btn.disabled = editMode; 
      });
      if (!editMode) widgetAddTable.style.display = 'none';
      document.querySelectorAll('.grid-item').forEach(item => {
        if (editMode) {
          item.classList.add('edit-mode-active');
          item.addEventListener('mousedown', dragStart);
          const removeBtn = item.querySelector('.remove-widget-btn');
          if (removeBtn) removeBtn.addEventListener('click', removeWidget);
        } else {
          item.classList.remove('edit-mode-active');
          item.removeEventListener('mousedown', dragStart);
          const removeBtn = item.querySelector('.remove-widget-btn');
          if (removeBtn) removeBtn.removeEventListener('click', removeWidget);
        }
      });
    });
    
    /* === Toggle Add Widget Button === */
    addWidgetBtn.addEventListener('click', () => {
      const currentDisplay = getComputedStyle(widgetAddTable).display;
      widgetAddTable.style.display = (currentDisplay === 'none' ? 'table' : 'none');
      updateRemovedWidgetsTable();
      if (document.getElementById('ratingsHistoryCard')) updateRatingsHistoryChart(currentUserId);
      if (document.getElementById('ratingsTimeFrameCard')) updateLongTermRatingHistory(currentUserId);
    });
    
    /* === Remove Widget === */
    function removeWidget(e) {
      e.stopPropagation();
      const widget = this.parentElement;
      const widgetName = widget.querySelector('h3') ? widget.querySelector('h3').textContent.trim() : widget.id;
      removedWidgets.push({ id: widget.id, element: widget, name: widgetName });
      widget.remove();
      updateRemovedWidgetsTable();
      if (widget.id === "ratingsHistoryCard") updateRatingsHistoryChart(currentUserId);
      if (widget.id === "ratingsTimeFrameCard") updateLongTermRatingHistory(currentUserId);
    }
    
    function updateRemovedWidgetsTable() {
      widgetAddTableBody.innerHTML = '';
      if (removedWidgets.length === 0) {
        widgetAddTable.style.display = 'none';
        return;
      }
      removedWidgets.forEach((w, index) => {
        const tr = document.createElement('tr');
        const tdName = document.createElement('td');
        tdName.textContent = w.name;
        const tdAdd = document.createElement('td');
        tdAdd.style.textAlign = 'center';
        const addBtn = document.createElement('button');
        addBtn.textContent = 'Restore';
        addBtn.style.cursor = 'pointer';
        addBtn.addEventListener('click', () => {
          document.getElementById('leftColumn').insertBefore(w.element, document.querySelector('#leftColumn .drop-zone'));
          removedWidgets.splice(index, 1);
          if (editMode) {
            w.element.classList.add('edit-mode-active');
            w.element.addEventListener('mousedown', dragStart);
            const removeBtn = w.element.querySelector('.remove-widget-btn');
            if (removeBtn) removeBtn.addEventListener('click', removeWidget);
          }
          updateRemovedWidgetsTable();
          if (w.element.id === "ratingsHistoryCard") updateRatingsHistoryChart(currentUserId);
          if (w.element.id === "ratingsTimeFrameCard") updateLongTermRatingHistory(currentUserId);
        });
        tdAdd.appendChild(addBtn);
        tr.appendChild(tdName);
        tr.appendChild(tdAdd);
        widgetAddTableBody.appendChild(tr);
      });
      widgetAddTable.style.display = 'table';
    }
    
    /* === Drag & Drop Logic === */
    function dragStart(e) {
      if (e.button !== 0) return;
      e.preventDefault();
      draggingItem = e.currentTarget;
      draggingItem.classList.add('dragging');
      document.addEventListener('mousemove', dragMove);
      document.addEventListener('mouseup', dragEnd);
    }
    
    function dragMove(e) {
      candidateWidget = null;
      candidateDropZone = null;
      document.querySelectorAll('.grid-item').forEach(item => {
        if (item === draggingItem) return;
        const rect = item.getBoundingClientRect();
        if (e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom) {
          candidateWidget = item;
          item.classList.add('highlight');
        } else {
          item.classList.remove('highlight');
        }
      });
      document.querySelectorAll('.drop-zone').forEach(zone => {
        const rect = zone.getBoundingClientRect();
        if (e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom) {
          candidateDropZone = zone;
          zone.classList.add('drop-highlight');
        } else {
          zone.classList.remove('drop-highlight');
        }
      });
      const scrollThreshold = 50, scrollSpeed = 20;
      if (e.clientY < scrollThreshold) window.scrollBy({ top: -scrollSpeed, behavior: 'smooth' });
      else if (e.clientY > window.innerHeight - scrollThreshold) window.scrollBy({ top: scrollSpeed, behavior: 'smooth' });
    }
    
    function dragEnd(e) {
      document.removeEventListener('mousemove', dragMove);
      document.removeEventListener('mouseup', dragEnd);
      document.querySelectorAll('.grid-item').forEach(item => item.classList.remove('highlight'));
      document.querySelectorAll('.drop-zone').forEach(zone => zone.classList.remove('drop-highlight'));
      if (candidateWidget && candidateWidget !== draggingItem) {
        swapNodes(draggingItem, candidateWidget);
      } else if (candidateDropZone) {
        candidateDropZone.parentElement.insertBefore(draggingItem, candidateDropZone);
      }
      if (window.ratingsHistoryChart && typeof window.ratingsHistoryChart.destroy === 'function') {
        window.ratingsHistoryChart.destroy();
      }
      draggingItem.classList.remove('dragging');
      if (document.getElementById('ratingsHistoryCard')) updateRatingsHistoryChart(currentUserId);
      if (document.getElementById('ratingsTimeFrameCard')) updateLongTermRatingHistory(currentUserId);
      draggingItem = candidateWidget = candidateDropZone = null;
    }
    
    function swapNodes(a, b) {
      const aParent = a.parentNode, bParent = b.parentNode;
      const aNext = a.nextSibling, bNext = b.nextSibling;
      if (aNext === b) aParent.insertBefore(b, a);
      else if (bNext === a) bParent.insertBefore(a, b);
      else {
        aParent.insertBefore(b, aNext);
        bParent.insertBefore(a, bNext);
      }
    }
    
    /* === Dynamic User Widgets === */
    function updateUserWidgets(userId, searchLocation) {
      currentUserId = userId;
      updateURLWithUser(userId);
      // Update hero card
      fetch(`/proxy/user/${userId}`)
        .then(res => res.json())
        .then(userData => {
          document.getElementById('heroName').textContent = userData.name;
          if (searchLocation) {
            document.getElementById('heroLocation').textContent = searchLocation;
          } else if (userData.mainAffiliation) {
            const loc = (userData.mainAffiliation.shortName || 'Location: N/A');
            document.getElementById('heroLocation').textContent = loc;
          }
          let ratingVal = userData.rating || userData.Intercom_Rating;
          ratingVal = ratingVal ? formatRating(ratingVal) : '--';
          document.getElementById('heroRating').textContent = 'Rating: ' + ratingVal;
        })
        .catch(err => console.error('Error fetching user profile:', err));
      
      fetch(`/proxy/user/${userId}/ratings`)
        .then(res => res.json())
        .then(data => {
          if (data.length > 0) {
            const ratingVal = formatRating(data[0].rating);
            document.getElementById('currentRatingValue').textContent = ratingVal;
            document.getElementById('heroRating').textContent = 'Rating: ' + ratingVal;
          }
        })
        .catch(err => console.error('Error fetching current rating:', err));
      
      fetch(`/proxy/user/${userId}/ratings-top`)
        .then(res => res.json())
        .then(data => {
          if (data.length > 0) {
            document.getElementById('highestRatingValue').textContent = formatRating(data[0].rating);
            const topDate = new Date(data[0].ratingPeriod);
            document.getElementById('highestRatingDateValue').textContent = topDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
          }
        })
        .catch(err => console.error('Error fetching highest rating:', err));
      
      fetch(`/proxy/user/${userId}/affiliations`)
        .then(res => res.json())
        .then(data => {
          const affWidget = document.getElementById('affiliationsWidget');
          const container = document.getElementById('affiliationsListContainer');
          container.innerHTML = "";
          if (!data || data.length === 0) {
            affWidget.style.display = 'none';
          } else {
            affWidget.style.display = '';
            data.forEach(affiliation => {
              const item = document.createElement('div');
              item.classList.add('affiliation-item');
              if (affiliation.logoImageUrl) {
                const logo = document.createElement('img');
                logo.src = affiliation.logoImageUrl;
                logo.alt = affiliation.descr || 'Affiliation logo';
                logo.classList.add('affiliation-logo');
                item.appendChild(logo);
              }
              const span = document.createElement('span');
              span.classList.add('affiliation-text');
              span.textContent = affiliation.descr;
              item.appendChild(span);
              container.appendChild(item);
            });
            if (container.children.length > 3 && !editMode) {
              if (!document.getElementById('affViewMoreBtn')) {
                const viewMoreBtn = document.createElement('button');
                viewMoreBtn.id = 'affViewMoreBtn';
                viewMoreBtn.className = 'view-more-btn';
                viewMoreBtn.textContent = 'View More';
                viewMoreBtn.addEventListener('click', () => {
                  if (editMode) return;
                  if (container.style.maxHeight === 'none') {
                    container.style.maxHeight = '200px';
                    viewMoreBtn.textContent = 'View More';
                  } else {
                    container.style.maxHeight = 'none';
                    viewMoreBtn.textContent = 'View Less';
                  }
                });
                affWidget.appendChild(viewMoreBtn);
              }
              container.style.maxHeight = '200px';
            }
          }
        })
        .catch(err => console.error('Error fetching affiliations:', err));
      
      updateLeaguesWidget(userId);
      updateSchoolsWidget(userId);
      updateCompletedMatches(userId);
      updateRatingsHistoryChart(userId);
      updateLongTermRatingHistory(userId);
      updateMonthlyRatingChangeWidget(userId);
      updateRecordCharts(userId);
    }
    
    // Updated function to update the Completed Matches widget using event cards.
    function updateCompletedMatches(userId) {
      fetch(`/proxy/user/${userId}/matches/page/1`)
        .then(res => res.json())
        .then(data => {
          const content = document.getElementById('completedMatchesContent');
          if (!data || !data.matches || data.matches.length === 0) {
            content.innerHTML = "<p>No completed matches found.</p>";
            return;
          }
          
          const currentUserName = document.getElementById('heroName').textContent.trim();
          let html = "";
          data.matches.forEach(match => {
            if(match.Status === "C") {
              const win = (match.wid1 == userId);
              let opponent = "";
              if (match.hplayer1 === currentUserName) {
                opponent = match.vplayer1;
              } else if (match.vplayer1 === currentUserName) {
                opponent = match.hplayer1;
              } else {
                opponent = win ? match.vplayer1 : match.hplayer1;
              }
              const matchDate = new Date(match.MatchDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
              // In the updateCompletedMatches function, modify the score formatting:
              const games = match.Score.split(',');
              // Reverse scores if user lost the match
              const formattedGames = games.map(game => {
                const [left, right] = game.split('-');
                return win ? `${left}-${right}` : `${right}-${left}`;
              });
              const formattedScore = formattedGames.join(' | ');

              // Then update the HTML generation:
              html += `
                <div class="event-card ${win ? 'win' : 'lose'}" data-matchid="${match.matchId || match.Matchid}">
                  <img src="https://ussq-img-live.s3.us-east-1.amazonaws.com/uploads%2Fussq-profile-icon-default.png" class="event-logo" alt="Match">
                  <div class="event-details">
                    <p>${matchDate}</p>
                    <p>Score: ${formattedScore}</p>
                    <p>${match.Descr || ''}</p>
                    <p>vs. ${opponent}</p>
                    
                  </div>
                  <button class="insights-btn" onclick="event.stopPropagation(); showGraphModal({ 
                    matchId: '${match.matchId || match.Matchid}', 
                    playerHome1Name: '${match.hplayer1}', 
                    playerVisiting1Name: '${match.vplayer1}' 
                  })">Match Insights</button>
                </div>
              `;
            }
          });
          content.innerHTML = html;
        })
        .catch(err => {
          console.error("Error fetching completed matches:", err);
          document.getElementById('completedMatchesContent').innerHTML = "<p>Error loading matches.</p>";
        });
    }
    
    // Function to open the match insights modal (existing version)
    function openMatchModal(matchId) {
      const modal = document.getElementById('matchModal');
      const modalBody = document.getElementById('modalBody');
      modal.style.display = 'block';
      modalBody.innerHTML = `<h3>Match Insights</h3>
                             <p>Match ID: ${matchId}</p>
                             <p>Loading match insights...</p>`;
      // Simulate API call; replace with real API call as needed.
      setTimeout(() => {
          modalBody.innerHTML = `<h3>Match Insights</h3>
                                 <p>Match ID: ${matchId}</p>
                                 <p>Score: [Score Info]</p>
                                 <p>Description: [Match Description]</p>
                                 <p>Date: [Match Date]</p>
                                 <p>Additional insights info...</p>`;
      }, 1000);
    }
    
    // NEW: Functions for the Graph Modal
    async function showGraphModal(match) {
      // Use fallback for match id if necessary
      const match_id = match.matchId || match.Matchid;
      if (!match_id) {
        alert("No matchId available for this match.");
        return;
      }
      const apiUrl = `/proxy/liveScoreDetails?match_id=${match_id}`;
      const graphStatus = document.getElementById("graph-status");
      graphStatus.textContent = "Loading match insights...";
    
      // Fetch data from the proxy.
      let data;
      try {
        const response = await fetch(apiUrl, { method: "GET", credentials: "include" });
        if (response.ok) {
          data = await response.json();
        } else {
          throw new Error("Proxy response not ok");
        }
      } catch (error) {
        console.error("Error fetching proxy data:", error);
        graphStatus.textContent = "Error loading match insights data.";
        return;
      }
    
      // Filter scoring events.
      const allPoints = data.filter(evt => evt.Decision === "point");
      if (allPoints.length < 2) {
        graphStatus.textContent = "Not enough scoring events to compute metrics.";
        return;
      }
      allPoints.sort((a, b) => new Date(a.StartDate) - new Date(b.StartDate));
    
      // Player names for labeling
      const homePlayerName = match.playerHome1Name || "Home Player";
      const visitingPlayerName = match.playerVisiting1Name || "Visiting Player";
    
      // Figure out how many games each player won (match score)
      const gameMap = {};
      for (let evt of allPoints) {
        const g = evt.Game_Number;
        if (!gameMap[g]) gameMap[g] = [];
        gameMap[g].push(evt);
      }
      const uniqueGames = Object.keys(gameMap).map(g => parseInt(g)).sort((a, b) => a - b);
    
      let homeGamesWon = 0;
      let visitingGamesWon = 0;
    
      // We'll store final game scores for a bar chart
      const homeGameScores = [];
      const visitingGameScores = [];
      const gameLabels = [];
    
      uniqueGames.forEach(gameNum => {
        const eventsInGame = gameMap[gameNum].sort((a, b) => new Date(a.StartDate) - new Date(b.StartDate));
        const finalLeft = eventsInGame[eventsInGame.length - 1].Points_left;
        const finalRight = eventsInGame[eventsInGame.length - 1].Points_right;
        gameLabels.push(`Game ${gameNum}`);
        homeGameScores.push(finalLeft);
        visitingGameScores.push(finalRight);
        if (finalLeft > finalRight) homeGamesWon++;
        else if (finalRight > finalLeft) visitingGamesWon++;
      });
    
      // Overall match length stats
      const firstTime = new Date(allPoints[0].StartDate);
      const lastTime = new Date(allPoints[allPoints.length - 1].StartDate);
      const matchLengthSec = (lastTime - firstTime) / 1000;
      const averagePointSec = matchLengthSec / (allPoints.length - 1);
    
      // Longest point in entire match
      let longestPointSec = 0;
      for (let i = 1; i < allPoints.length; i++) {
        const diffSec = (new Date(allPoints[i].StartDate) - new Date(allPoints[i-1].StartDate)) / 1000;
        if (diffSec > longestPointSec) longestPointSec = diffSec;
      }
    
      // Average game length
      const gameLengthsSec = uniqueGames.map(g => {
        const events = gameMap[g].sort((a, b) => new Date(a.StartDate) - new Date(b.StartDate));
        const start = new Date(events[0].StartDate);
        const end = new Date(events[events.length-1].StartDate);
        return (end - start) / 1000;
      });
      const averageGameSec = gameLengthsSec.reduce((a, b) => a + b, 0) / gameLengthsSec.length;
    
      // Build tabbed interface
      const tabNav = document.createElement("div");
      tabNav.id = "tab-nav";
    
      const tabContent = document.createElement("div");
      tabContent.id = "tab-content";
    
      // Overview tab button
      const overviewTabBtn = document.createElement("button");
      overviewTabBtn.textContent = "Overview";
      overviewTabBtn.classList.add("tab-button", "active");
      tabNav.appendChild(overviewTabBtn);
    
      // Overview tab content
      const overviewContent = document.createElement("div");
      overviewContent.classList.add("tab-content-pane");
      overviewContent.id = "overview-tab";
      overviewContent.style.display = "block";
    
      // Match Score
      const matchScoreDiv = document.createElement("div");
      matchScoreDiv.style.marginBottom = "15px";
      matchScoreDiv.innerHTML = `
        <h3 style="margin-bottom:5px;">Match Score</h3>
        <p>${homePlayerName} <strong>${homeGamesWon}</strong> - <strong>${visitingGamesWon}</strong> ${visitingPlayerName}</p>
      `;
      overviewContent.appendChild(matchScoreDiv);
    
      // Additional stats row
      const overviewStats = document.createElement("div");
      overviewStats.style.display = "flex";
      overviewStats.style.justifyContent = "center";
      overviewStats.style.gap = "30px";
      overviewStats.style.marginBottom = "15px";
    
      function makeStatBox(label, value) {
        const box = document.createElement("div");
        box.style.backgroundColor = "#f8f8f8";
        box.style.padding = "8px 12px";
        box.style.borderRadius = "6px";
        box.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
        box.innerHTML = `<strong>${label}:</strong> ${value}`;
        return box;
      }
      overviewStats.appendChild(makeStatBox("Match Length", formatDurationSec(matchLengthSec)));
      overviewStats.appendChild(makeStatBox("Avg Point", formatDurationSec(averagePointSec)));
      overviewStats.appendChild(makeStatBox("Longest Point", formatDurationSec(longestPointSec)));
      overviewStats.appendChild(makeStatBox("Avg Game", formatDurationSec(averageGameSec)));
      overviewContent.appendChild(overviewStats);
    
      // Bar chart for game scores
      const barChartDiv = document.createElement("div");
      barChartDiv.style.maxWidth = "600px";
      barChartDiv.style.margin = "0 auto 20px auto";
      const barCanvas = document.createElement("canvas");
      barCanvas.id = "game-scores-bar-chart";
      barChartDiv.appendChild(barCanvas);
      overviewContent.appendChild(barChartDiv);
    
      new Chart(barCanvas.getContext('2d'), {
        type: 'bar',
        data: {
          labels: gameLabels,
          datasets: [
            {
              label: homePlayerName,
              data: homeGameScores,
              backgroundColor: 'red'
            },
            {
              label: visitingPlayerName,
              data: visitingGameScores,
              backgroundColor: 'blue'
            }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: '#333' }
            },
            y: {
              grid: { color: 'rgba(0,0,0,0.1)' },
              ticks: { color: '#333' }
            }
          }
        }
      });
    
      tabContent.appendChild(overviewContent);
    
      // Create a tab for each game
      uniqueGames.forEach(gameNum => {
        const gameTabBtn = document.createElement("button");
        gameTabBtn.textContent = `Game ${gameNum}`;
        gameTabBtn.classList.add("tab-button");
        tabNav.appendChild(gameTabBtn);
    
        const gameContent = document.createElement("div");
        gameContent.classList.add("tab-content-pane");
        gameContent.id = `game-tab-${gameNum}`;
        gameContent.style.display = "none";
    
        const pointsGame = gameMap[gameNum].sort((a, b) => new Date(a.StartDate) - new Date(b.StartDate));
        if (pointsGame.length === 0) {
          gameContent.innerHTML = `<div style="text-align:center; font-size:16px;">No data for Game ${gameNum}</div>`;
        } else {
          const finalLeft = pointsGame[pointsGame.length - 1].Points_left;
          const finalRight = pointsGame[pointsGame.length - 1].Points_right;
          const start = new Date(pointsGame[0].StartDate);
          const end = new Date(pointsGame[pointsGame.length - 1].StartDate);
          const gameLengthSec = (end - start) / 1000;
    
          const intervals = [];
          for (let i = 1; i < pointsGame.length; i++) {
            const diffSec = (new Date(pointsGame[i].StartDate) - new Date(pointsGame[i-1].StartDate)) / 1000;
            intervals.push(diffSec);
          }
          const longestPointSecGame = intervals.length ? Math.max(...intervals) : 0;
          const avgPointSecGame = intervals.length ? intervals.reduce((a, b) => a + b, 0) / intervals.length : 0;
    
          const scoreboardDiv = document.createElement("div");
          scoreboardDiv.style.marginBottom = "15px";
          scoreboardDiv.innerHTML = `
            <h3>Final Score for Game ${gameNum}</h3>
            <p><strong>${homePlayerName}:</strong> ${finalLeft} | <strong>${visitingPlayerName}:</strong> ${finalRight}</p>
            <div style="display:flex; justify-content:center; gap:20px; margin-top:10px;">
              <div style="background:#f8f8f8; padding:6px 10px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                <strong>Game Length:</strong> ${formatDurationSec(gameLengthSec)}
              </div>
              <div style="background:#f8f8f8; padding:6px 10px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                <strong>Avg Point:</strong> ${formatDurationSec(avgPointSecGame)}
              </div>
              <div style="background:#f8f8f8; padding:6px 10px; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                <strong>Longest Point:</strong> ${formatDurationSec(longestPointSecGame)}
              </div>
            </div>
          `;
          gameContent.appendChild(scoreboardDiv);
    
          const x = pointsGame.map(evt => evt.Points_left + evt.Points_right);
          const p1_scores = pointsGame.map(evt => evt.Points_left);
          const p2_scores = pointsGame.map(evt => evt.Points_right);
    
          const lineCanvas = document.createElement("canvas");
          lineCanvas.style.maxWidth = "100%";
          lineCanvas.style.maxHeight = "35%";
          gameContent.appendChild(lineCanvas);
    
          new Chart(lineCanvas.getContext('2d'), {
            type: 'line',
            data: {
              labels: x,
              datasets: [
                {
                  label: homePlayerName,
                  data: p1_scores,
                  borderColor: 'red',
                  backgroundColor: 'red',
                  fill: false,
                  tension: 0.1,
                  pointStyle: 'circle',
                  borderWidth: 2
                },
                {
                  label: visitingPlayerName,
                  data: p2_scores,
                  borderColor: 'blue',
                  backgroundColor: 'blue',
                  fill: false,
                  tension: 0.1,
                  pointStyle: 'circle',
                  borderWidth: 2
                }
              ]
            },
            options: {
              responsive: true,
              plugins: { legend: { display: true } },
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Points Played' },
                  ticks: { stepSize: 1, color: '#333' },
                  grid: { color: 'rgba(0,0,0,0.1)', drawBorder: false }
                },
                y: {
                  title: { display: true, text: 'Score' },
                  ticks: { color: '#333' },
                  grid: { color: 'rgba(0,0,0,0.1)', drawBorder: false }
                }
              }
            }
          });
    
          const intervalCanvas = document.createElement("canvas");
          intervalCanvas.style.maxWidth = "100%";
          intervalCanvas.style.height = "200px";
          gameContent.appendChild(intervalCanvas);
    
          const intervalLabels = intervals.map((_, idx) => `Interval ${idx+1}`);
          new Chart(intervalCanvas.getContext('2d'), {
            type: 'bar',
            data: {
              labels: intervalLabels,
              datasets: [
                {
                  label: 'Time Between Points (sec)',
                  data: intervals,
                  backgroundColor: '#8c564b'
                }
              ]
            },
            options: {
              responsive: true,
              scales: {
                x: { grid: { display: false }, ticks: { color: '#333' } },
                y: { grid: { color: 'rgba(0,0,0,0.1)' }, ticks: { color: '#333' } }
              }
            }
          });
        }
        tabContent.appendChild(gameContent);
    
        gameTabBtn.addEventListener("click", () => {
          tabContent.querySelectorAll(".tab-content-pane").forEach(pane => pane.style.display = "none");
          tabNav.querySelectorAll(".tab-button").forEach(btn => btn.classList.remove("active"));
          gameContent.style.display = "block";
          gameTabBtn.classList.add("active");
        });
      });
    
      overviewTabBtn.addEventListener("click", () => {
        tabContent.querySelectorAll(".tab-content-pane").forEach(pane => pane.style.display = "none");
        tabNav.querySelectorAll(".tab-button").forEach(btn => btn.classList.remove("active"));
        overviewContent.style.display = "block";
        overviewTabBtn.classList.add("active");
      });
    
      const metricsContainer = document.getElementById("metrics-container");
      metricsContainer.innerHTML = "";
      metricsContainer.appendChild(tabNav);
      metricsContainer.appendChild(tabContent);
    
      graphStatus.textContent = "";
      document.getElementById("graph-modal").style.display = "block";
    }
    
    function closeGraphModal() {
      document.getElementById("graph-modal").style.display = "none";
    }
    document.getElementById("graph-close").addEventListener("click", closeGraphModal);
    window.addEventListener("click", function (event) {
      const graphModal = document.getElementById("graph-modal");
      if (event.target == graphModal) graphModal.style.display = "none";
    });
    
    function updateRecordCharts(userId) {
      fetch(`/proxy/user/${userId}/record`)
        .then(res => res.json())
        .then(data => {
          let singlesWins = {3:0,4:0,5:0}, singlesLosses = {3:0,4:0,5:0},
              doublesWins = {3:0,4:0,5:0}, doublesLosses = {3:0,4:0,5:0};
          if (data && data.length > 0) {
            data.forEach(item => {
              if (item.type === 'S') {
                singlesWins[item.matchesType] += item.matchesWon;
                singlesLosses[item.matchesType] += item.matchesLost;
              } else if (item.type === 'D') {
                doublesWins[item.matchesType] += item.matchesWon;
                doublesLosses[item.matchesType] += item.matchesLost;
              }
            });
          }
          // Destroy previous instances if they exist before creating new charts
          if(singlesWinsChart) singlesWinsChart.destroy();
          singlesWinsChart = createStyledDoughnutChart('singlesWinsChart', [singlesWins[3], singlesWins[4], singlesWins[5]], 'Singles Wins', fixedColors);
          if(singlesLossesChart) singlesLossesChart.destroy();
          singlesLossesChart = createStyledDoughnutChart('singlesLossesChart', [singlesLosses[3], singlesLosses[4], singlesLosses[5]], 'Singles Losses', fixedColors);
          if((doublesWins[3] + doublesWins[4] + doublesWins[5]) > 0) {
            document.getElementById('doublesWinsBox').style.display = '';
            if(doublesWinsChart) doublesWinsChart.destroy();
            doublesWinsChart = createStyledDoughnutChart('doublesWinsChart', [doublesWins[3], doublesWins[4], doublesWins[5]], 'Doubles Wins', fixedColors);
          } else {
            document.getElementById('doublesWinsBox').style.display = 'none';
          }
          if((doublesLosses[3] + doublesLosses[4] + doublesLosses[5]) > 0) {
            document.getElementById('doublesLossesBox').style.display = '';
            if(doublesLossesChart) doublesLossesChart.destroy();
            doublesLossesChart = createStyledDoughnutChart('doublesLossesChart', [doublesLosses[3], doublesLosses[4], doublesLosses[5]], 'Doubles Losses', fixedColors);
          } else {
            document.getElementById('doublesLossesBox').style.display = 'none';
          }
        });
    }
    
    function updateLeaguesWidget(userId) {
      fetch(`/proxy/players/${userId}/leagues`)
        .then(res => res.json())
        .then(data => {
          const widget = document.getElementById('leaguesWidget');
          const leaguesList = document.getElementById('leaguesList');
          leaguesList.innerHTML = "";
          const table = document.createElement('table');
          table.classList.add('styled-table');
          const thead = document.createElement('thead');
          const headerRow = document.createElement('tr');
          ['Team', 'League', 'Start Date', 'End Date'].forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          if (data && data.length > 0) {
            const sorted = data.sort((a, b) => new Date(b.StartDate) - new Date(a.StartDate));
            sorted.forEach(league => {
              const tr = document.createElement('tr');
              const teamTd = document.createElement('td');
              teamTd.textContent = league.Teamname;
              const leagueTd = document.createElement('td');
              leagueTd.textContent = league.LeagueDescr;
              const startTd = document.createElement('td');
              const startDate = new Date(league.StartDate.substring(0,10));
              startTd.textContent = startDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
              const endTd = document.createElement('td');
              const endDate = new Date(league.EndDate.substring(0,10));
              endTd.textContent = endDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
              tr.appendChild(teamTd);
              tr.appendChild(leagueTd);
              tr.appendChild(startTd);
              tr.appendChild(endTd);
              tbody.appendChild(tr);
            });
          } else {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 4;
            td.textContent = "No data available";
            tr.appendChild(td);
            tbody.appendChild(tr);
          }
          table.appendChild(tbody);
          const container = document.createElement('div');
          container.className = 'table-container';
          container.appendChild(table);
          leaguesList.appendChild(container);
          if (table.tBodies[0].rows.length > 4 && !editMode) {
            const viewMoreBtn = document.createElement('button');
            viewMoreBtn.className = 'view-more-btn';
            viewMoreBtn.textContent = 'View More';
            viewMoreBtn.addEventListener('click', () => {
              if (editMode) return;
              if (container.style.maxHeight === 'none') {
                container.style.maxHeight = '200px';
                viewMoreBtn.textContent = 'View More';
              } else {
                container.style.maxHeight = 'none';
                viewMoreBtn.textContent = 'View Less';
              }
            });
            leaguesList.appendChild(viewMoreBtn);
          }
        })
        .catch(err => console.error('Error fetching leagues:', err));
    }
    
    function updateSchoolsWidget(userId) {
      fetch(`/proxy/user/${userId}/schools`)
        .then(res => res.json())
        .then(data => {
          const widget = document.getElementById('schoolsWidget');
          widget.innerHTML = "";
          const header = document.createElement('h3');
          header.textContent = 'Schools';
          widget.appendChild(header);
          const tableContainer = document.createElement('div');
          tableContainer.className = 'table-container';
          const table = document.createElement('table');
          table.classList.add('styled-table');
          const thead = document.createElement('thead');
          const headerRow = document.createElement('tr');
          ['School', 'Grad Year', 'Team Captain'].forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          if (data && data.length > 0) {
            data.forEach(school => {
              const tr = document.createElement('tr');
              const tdDescr = document.createElement('td');
              tdDescr.textContent = school.Descr || school.Level || '';
              const tdGradYear = document.createElement('td');
              tdGradYear.textContent = school.GradYear;
              const tdTeamCaptain = document.createElement('td');
              tdTeamCaptain.textContent = school.TeamCaptain;
              tr.appendChild(tdDescr);
              tr.appendChild(tdGradYear);
              tr.appendChild(tdTeamCaptain);
              tbody.appendChild(tr);
            });
          } else {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 3;
            td.textContent = "No data available";
            tr.appendChild(td);
            tbody.appendChild(tr);
          }
          table.appendChild(tbody);
          tableContainer.appendChild(table);
          widget.appendChild(tableContainer);
          if (table.tBodies[0].rows.length > 4 && !editMode) {
            const viewMoreBtn = document.createElement('button');
            viewMoreBtn.className = 'view-more-btn';
            viewMoreBtn.textContent = 'View More';
            viewMoreBtn.addEventListener('click', () => {
              if (editMode) return;
              if (tableContainer.style.maxHeight === 'none') {
                tableContainer.style.maxHeight = '200px';
                viewMoreBtn.textContent = 'View More';
              } else {
                tableContainer.style.maxHeight = 'none';
                viewMoreBtn.textContent = 'View Less';
              }
            });
            widget.appendChild(viewMoreBtn);
          }
        })
        .catch(err => console.error('Error fetching schools:', err));
    }
    
    function updateRatingsHistoryChart(userId) {
      fetch(`/proxy/user/${userId}/ratings_history`)
        .then(res => res.json())
        .then(data => {
          const filtered = data.filter(entry => entry.RatingGroup === "Singles International Rating");
          const widget = document.getElementById('ratingsHistoryCard');
          if (!filtered || filtered.length === 0) {
            widget.style.display = 'none';
            return;
          } else {
            widget.style.display = '';
          }
          const labels = filtered.map(entry => {
            const date = new Date(entry.RankingPeriod);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          }).reverse();
          const ratings = filtered.map(entry => entry.NewRating).reverse();
          const ctx = document.getElementById('ratingsHistoryChart').getContext('2d');
          if (window.ratingsHistoryChart && typeof window.ratingsHistoryChart.destroy === 'function') {
            window.ratingsHistoryChart.destroy();
          }
          window.ratingsHistoryChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [{
                label: 'Rating',
                data: ratings,
                borderColor: '#4facfe',
                backgroundColor: 'rgba(79, 172, 254, 0.3)',
                fill: true,
                tension: 0.3,
                pointRadius: 3,
                pointHoverRadius: 5
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              scales: {
                x: { title: { display: true, text: 'Date' } },
                y: { title: { display: true, text: 'Rating' } }
              },
              plugins: {
                legend: { display: false },
                tooltip: {
                  backgroundColor: '#fff',
                  titleColor: '#333',
                  bodyColor: '#666',
                  borderColor: '#ddd',
                  borderWidth: 1,
                  padding: 8
                }
              }
            }
          });
        })
        .catch(err => console.error('Error fetching ratings history:', err));
    }

    
    function updateLongTermRatingHistory(userId) {
      const apiUrl = `/proxy/user/${userId}/rankings`;
      fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
          let filtered = data.filter(item => item.RatingGroupDescr === "Universal Squash Rating");
          if (filtered.length === 0) {
            document.getElementById('ratingsTimeFrameCard').style.display = 'none';
            return;
          } else {
            document.getElementById('ratingsTimeFrameCard').style.display = '';
          }
          filtered.sort((a, b) => new Date(a.RankingPeriod) - new Date(b.RankingPeriod));
          const deduped = [];
          const seenDates = new Set();
          filtered.forEach(item => {
            const dateStr = new Date(item.RankingPeriod).toISOString().split('T')[0];
            if (!seenDates.has(dateStr)) {
              seenDates.add(dateStr);
              deduped.push(item);
            }
          });
          window.rankingHistoryData = deduped;
          const minDate = new Date(deduped[0].RankingPeriod);
          const maxDate = new Date(deduped[deduped.length - 1].RankingPeriod);
          window.rankingHistoryMinDate = minDate;
          window.rankingHistoryMaxDate = maxDate;
          const totalMonths = (maxDate.getFullYear() - minDate.getFullYear()) * 12 +
                              (maxDate.getMonth() - minDate.getMonth());
          const options = generateTimeFrameOptions(totalMonths);
          populateTimeFrameSelect(options);

        // Start with the third option (index 2)
        const defaultTimeFrame = options[3].value; // Third option
        const filteredByTime = filterDataByTimeFrame(window.rankingHistoryData, defaultTimeFrame);
        renderLongTermChart(filteredByTime);
        
        // Set the third button as active
        const buttons = document.querySelectorAll('.timeframe-btn');
        if (buttons.length > 3) {
          buttons[3].classList.add('active');
        }
      })
      .catch(err => console.error(err));
      
      function generateTimeFrameOptions(totalMonths) {
        let opts = [];
        opts.push({ label: "All Time", value: "all" });
        if(totalMonths >= 60) {
          opts.push({ label: "5 Years", value: 60 });
          opts.push({ label: "3 Years", value: 36 });
          opts.push({ label: "1 Year", value: 12 });
          opts.push({ label: "6 Months", value: 6 });
        } else if(totalMonths >= 36) {
          opts.push({ label: "3 Years", value: 36 });
          opts.push({ label: "2 Years", value: 24 });
          opts.push({ label: "1 Year", value: 12 });
          opts.push({ label: "6 Months", value: 6 });
        } else if(totalMonths >= 12) {
          opts.push({ label: "1 Year", value: 12 });
          opts.push({ label: "9 Months", value: 9 });
          opts.push({ label: "6 Months", value: 6 });
          opts.push({ label: "3 Months", value: 3 });
        } else {
          opts.push({ label: "6 Months", value: 6 });
          opts.push({ label: "3 Months", value: 3 });
          opts.push({ label: "1 Month", value: 1 });
          opts.push({ label: "2 Weeks", value: 0.5 });
        }
        return opts;
      }
      
      function populateTimeFrameSelect(options) {
        const container = document.getElementById('timeFrameButtons');
        container.innerHTML = '';
        
        options.forEach((opt, index) => {
          const btn = document.createElement('button');
          btn.className = 'timeframe-btn';
          btn.textContent = opt.label;
          btn.dataset.value = opt.value;
          
          // Remove this line since we're setting active state in updateLongTermRatingHistory
          // if (opt.value === "all") btn.classList.add('active');
          
          btn.addEventListener('click', function() {
            // Remove active class from all buttons
            container.querySelectorAll('.timeframe-btn').forEach(b => 
              b.classList.remove('active')
            );
            // Add active class to clicked button
            this.classList.add('active');
            // Filter data and update chart
            const filteredByTime = filterDataByTimeFrame(window.rankingHistoryData, this.dataset.value);
            renderLongTermChart(filteredByTime);
          });
          
          container.appendChild(btn);
        });
      }
      
      function filterDataByTimeFrame(data, timeFrameValue) {
        if(timeFrameValue === "all") return data;
        const months = parseFloat(timeFrameValue);
        const maxDate = window.rankingHistoryMaxDate;
        const cutoff = new Date(maxDate);
        cutoff.setMonth(cutoff.getMonth() - months);
        return data.filter(item => new Date(item.RankingPeriod) >= cutoff);
      }
      
      function renderLongTermChart(data) {
        const ctx = document.getElementById('ratingsTimeFrameChart').getContext('2d');
        const showYear = window.rankingHistoryMinDate.getFullYear() !== window.rankingHistoryMaxDate.getFullYear();
        const labels = data.map(item => {
          const d = new Date(item.RankingPeriod);
          return showYear ?
            d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) :
            d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        });
        const ratingValues = data.map(item => item.Rating);
        if(window.myRankingChart) {
          window.myRankingChart.destroy();
        }
        window.myRankingChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Rating Over Time',
              data: ratingValues,
              fill: true,
              borderColor: '#4facfe',
              backgroundColor: 'rgba(79, 172, 254, 0.3)',
              tension: 0.3,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: {
              x: { title: { display: true, text: 'Date' } },
              y: { title: { display: true, text: 'Rating' } }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: '#fff',
                titleColor: '#333',
                bodyColor: '#666',
                borderColor: '#ddd',
                borderWidth: 1,
                padding: 8
              }
            }
          }
        });
      }
    }
    
    function updateMonthlyRatingChangeWidget(userId) {
      fetch(`/proxy/user/${userId}/ratings_history`)
        .then(res => res.json())
        .then(data => {
          data = data.filter(entry => entry.RatingGroup === "Singles International Rating");
          if (!data || data.length === 0) {
            document.getElementById('ratingChangeWidget').style.display = 'none';
            return;
          } else {
            document.getElementById('ratingChangeWidget').style.display = '';
          }
          data.sort((a, b) => new Date(a.RankingPeriod) - new Date(b.RankingPeriod));
          let html = '';
          let yearlyChange = 0;
          const oneYearAgo = new Date();
          oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
          for (let i = 1; i < data.length; i++) {
            const prev = data[i-1], curr = data[i];
            let diff = curr.NewRating - prev.NewRating;
            if (Math.abs(diff) > 20) continue;
            diff = parseFloat(diff.toFixed(2));
            if (new Date(curr.RankingPeriod) >= oneYearAgo) yearlyChange += diff;
            const month = new Date(curr.RankingPeriod).toLocaleString('en-US', { month: 'short' });
            const color = diff > 0 ? '#2f80ed' : diff < 0 ? '#1c64a0' : '#333';
            const sign = diff > 0 ? '+' : '';
            html += `<div class="rating-change-item"><span class="month">${month}</span><span class="diff" style="color: ${color};">${sign}${diff}</span></div>`;
          }
          document.getElementById('yearlyRatingChange').textContent = 'Past Year Change: ' + (yearlyChange > 0 ? '+' : '') + yearlyChange.toFixed(2);
          document.getElementById('ratingChangeList').innerHTML = html;
        })
        .catch(err => console.error('Error fetching monthly rating change:', err));
    }
    
    const fixedColors = ['#4facfe', '#2f80ed', '#1c64a0'];
    
    function createStyledDoughnutChart(canvasId, dataValues, titleText, colors) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const chart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['3-game match', '4-game match', '5-game match'],
          datasets: [{
            data: dataValues,
            backgroundColor: colors,
            hoverOffset: 0,
            borderWidth: 2,
            borderColor: '#fff'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: { display: false },
            title: { display: false },
            tooltip: {
              backgroundColor: '#fff',
              titleColor: '#333',
              bodyColor: '#666',
              borderColor: '#ddd',
              borderWidth: 1,
              padding: 8
            }
          }
        }
      });
      chart._originalData = dataValues.slice();
      chart._hidden = [false, false, false];
      chart._originalColors = colors;
      chart._chartTitle = titleText;
      renderLegend(chart, canvasId + '-legend');
      updateTotal(chart);
      return chart;
    }
    
    function updateTotal(chart) {
      const total = chart.data.datasets[0].data.reduce((sum, val) => sum + val, 0);
      const headerEl = document.getElementById(chart.canvas.id + '-header');
      if (headerEl) {
        const titleEl = headerEl.querySelector('.chart-title-total');
        if (titleEl) titleEl.textContent = chart._chartTitle + ' - ' + total;
      }
    }
    
    function toggleSegment(chart, index) {
      if (!chart._hidden) chart._hidden = [];
      if (chart._hidden[index]) {
        chart.data.datasets[0].data[index] = chart._originalData[index];
        chart._hidden[index] = false;
      } else {
        chart.data.datasets[0].data[index] = 0;
        chart._hidden[index] = true;
      }
      chart.update();
      renderLegend(chart, chart.canvas.id + '-legend');
      updateTotal(chart);
    }
    
    function renderLegend(chart, containerId) {
      const container = document.getElementById(containerId);
      container.innerHTML = "";
      chart.data.labels.forEach((label, index) => {
        if (chart._originalData[index] <= 0) return;
        const legendItem = document.createElement('div');
        legendItem.style.display = 'inline-block';
        legendItem.style.marginRight = '10px';
        legendItem.style.cursor = 'pointer';
        const swatch = document.createElement('span');
        swatch.style.display = 'inline-block';
        swatch.style.width = '8px';
        swatch.style.height = '8px';
        swatch.style.backgroundColor = chart._originalColors[index];
        swatch.style.marginRight = '5px';
        if (chart._hidden && chart._hidden[index]) swatch.style.opacity = '0.3';
        legendItem.appendChild(swatch);
        const text = document.createElement('span');
        text.textContent = label + ' (' + chart._originalData[index] + ')';
        legendItem.appendChild(text);
        legendItem.addEventListener('click', () => { toggleSegment(chart, index); });
        container.appendChild(legendItem);
      });
    }
    /* === Search Functionality === */
    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        if (timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
      };
    }
    
    const performSearchDebounced = debounce(performSearch, 300);
    searchInput.addEventListener('input', performSearchDebounced);
    
    function performSearch() {
      const query = searchInput.value.trim();
      if (!query) {
        searchResultsDiv.style.display = "none";
        searchResultsDiv.innerHTML = "";
        return;
      }
      fetch(`/proxy/search?q=${encodeURIComponent(query)}`)
        .then(res => res.json())
        .then(data => {
          searchResultsDiv.innerHTML = "";
          const players = data.filter(item => item.ObjectType === "Player");
          if (!players || players.length === 0) { 
            searchResultsDiv.style.display = "none"; 
            return; 
          }
          players.forEach(item => {
            const div = document.createElement('div');
            let imgHTML = "";
            if (item.LogoImageUrl) {
              imgHTML = `<img src="${item.LogoImageUrl}" alt="${item.ObjectName}">`;
            }
            const locText = item.ObjectLocation ? ` - ${item.ObjectLocation}` : "";
            div.innerHTML = `${imgHTML}<span>${item.ObjectName}${locText}</span>`;
            div.addEventListener('click', () => {
              updateUserWidgets(item.ObjectId, item.ObjectLocation);
              searchResultsDiv.style.display = "none";
              searchResultsDiv.innerHTML = "";
              searchInput.value = "";
            });
            searchResultsDiv.appendChild(div);
          });
          const rect = searchInput.getBoundingClientRect();
          searchResultsDiv.style.top = (rect.bottom + window.scrollY) + "px";
          searchResultsDiv.style.left = (rect.left + window.scrollX) + "px";
          searchResultsDiv.style.width = rect.width + "px";
          searchResultsDiv.style.display = "block";
        })
        .catch(err => console.error('Error during search:', err));
    }
    // Initially update the donut charts for the default user
    updateRecordCharts(currentUserId);
    
    window.addEventListener('DOMContentLoaded', () => {
      const params = new URLSearchParams(window.location.search);
      const userIdParam = params.get('user_id');
      if (userIdParam) {
        currentUserId = parseInt(userIdParam);
        updateUserWidgets(currentUserId);
      }
    });
  </script>
</body>
</html>